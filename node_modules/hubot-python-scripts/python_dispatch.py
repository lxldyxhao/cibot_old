# coding=utf-8
import imp
import os
import sys
import inspect
import json
import re
import time
import pymysql
import traceback
import logging
import re

# 通过下面的方式进行简单配置输出方式与日志级别
logging.basicConfig(filename='logger2.log', level=logging.INFO,
                    format="%(asctime)s %(filename)s %(lineno)d %(message)s",
                    datefmt="%a %d %b %Y %H:%M:%S")

from scripts import hubot_script

class HubotDispatch(object):

  def __init__(self):
    self.hear_regexes = {}
    self.resp_regexes = {}
    self.instance_map = {}
    self.load_scripts()
    self.start_listening()

  def start_listening(self):
    while True:
      line = sys.stdin.readline()
      if line:
        self.receive(line)
      else:
        return

  def receive(self, json_str):
    try:
      json_dict = json.loads(json_str)
      self.dispatch(json_dict)
    except Exception as e:
      pass

  def send(self, message):
    if message:
      sys.stdout.write(json.dumps(message) + '\n')
      sys.stdout.flush()

  def dispatch(self, json_dict):
    msg_type = json_dict['type']
    if msg_type == 'hear':
      json_dict['message'] = json_dict['message']
      # 保存聊天记录
      self.saveChat(json_dict)
      self.dispatch_generic(json_dict, self.hear_regexes)
    elif msg_type == 'respond':
      self.dispatch_generic(json_dict, self.resp_regexes)
      # 保存聊天记录
      self.saveChat(json_dict)

  def saveChat(self, msg):
    # 获取UseName->昵称
    # 自动编号,昵称,内容,时间
    username = msg['user']['name']
    text = msg['message']
    config = {
      'host': 'localhost',
      'port': 3306,
      'user': 'root',
      'password': 'password',
      'db': 'hubot',
      'charset': 'utf8mb4',
      'cursorclass': pymysql.cursors.DictCursor,
    }
    conn = pymysql.connect(**config)
    cursor = conn.cursor()
    cursor.execute('SELECT NickName FROM contact WHERE UserName = %s', [username])
    conn.commit()
    nickname = cursor.fetchone()['NickName']
    if nickname is not None:
      value = (nickname, "呆呆的石头", text)
      cursor.execute('INSERT INTO chat (fromnickname,tonickname,content) VALUES (%s,%s,%s)', value)
      conn.commit()

  def dispatch_generic(self, message, regexes):
    for regex in regexes:
      search = re.search(regex, message['message'], re.IGNORECASE)
      if search:
        handler = regexes[regex]
        response = message
        instance = self.instance_map[handler]
        try:

          #####################################################
          #  最好在这加一个判断  handler(instance, message, search.groups()) 返回值是否为 None ,不为才进行后续操作
          # ,可以减少出错可能性,不加,正常下可以
          #  ,但是数据库数据混乱,数据丢失 就会报错
          ######################################################


          response_text = "" + handler(instance, message, search.groups())
          if response_text:
            # response['message'] = json.dumps(response)
            # self.send(response)
            datalist = response_text.split('&&')

            if int(datalist[0]) == 0:  # 发布问题成功
              # response['message'] = response_text
              # self.send(response)
              msg = json.loads(datalist[1])
              msg['user']['room'] = message['user']['room']
              self.send(msg)

              for i in range(2, len(datalist)):
                msg1 = json.loads(datalist[i])
                msg1['user']['room'] = message['user']['room']
                self.send(msg1)

            elif int(datalist[0]) == 1:  # 发布回答成功
              msg = json.loads(datalist[1])
              msg['user']['room'] = message['user']['room']
              self.send(msg)

              for i in range(2, len(datalist)):
                msg1 = json.loads(datalist[i])
                msg1['user']['room'] = message['user']['room']
                self.send(msg1)

            elif int(datalist[0]) == 2:  # 评论回答成功
              msg = json.loads(datalist[1])
              msg['user']['room'] = message['user']['room']
              self.send(msg)

              for i in range(2, len(datalist)):
                msg1 = json.loads(datalist[i])
                msg1['user']['room'] = message['user']['room']
                self.send(msg1)

            elif int(datalist[0]) == -1:  # 发布问题(或回答)失败,提示用户他的积分不够
              msg = json.loads(datalist[1])
              msg['user']['room'] = message['user']['room']
              self.send(msg)

        except Exception as e:
          traceback.print_exc()
          #################################################
          # 实际应用,这里就不要发送啦
          ####################################################
          response['message'] = 'Python exception: {0}'.format(str(e))
          self.send(response)

  def no_handler(self, message):
    pass

  def load_scripts(self):
    prefix = '{root}{sep}'.format(root=os.path.dirname(os.path.realpath(__file__)), sep=os.sep)
    sys.path.append('{0}scripts'.format(prefix))
    package = json.load(open('{0}package.json'.format(prefix)))
    self.scripts = []
    for filename in package['enabled_scripts']:
      modname = filename.replace('.py', '')
      modf = imp.find_module(modname)
      hubot_script._hear_regexes.clear()
      hubot_script._resp_regexes.clear()
      try:
        mod = imp.load_module(modname, *modf)
        regexes = {}
        regexes.update(hubot_script._hear_regexes)
        regexes.update(hubot_script._resp_regexes)
        self.hear_regexes.update(hubot_script._hear_regexes)
        self.resp_regexes.update(hubot_script._resp_regexes)

        for name, member in inspect.getmembers(mod):
          if inspect.isclass(member):
            if issubclass(member, hubot_script.HubotScript) and member != hubot_script.HubotScript:
              instance = member()
              for key in regexes:
                self.instance_map[regexes[key]] = instance
              self.scripts += [instance]
      except Exception as e:
        pass


if __name__ == '__main__':
  dispatch = HubotDispatch()
