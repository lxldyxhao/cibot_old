# coding=utf-8
from scripts.hubot_script import *
import pymysql
import json
import traceback
import logging
import re
import gensim
import jieba.posseg as pseg
import heapq

# 通过下面的方式进行简单配置输出方式与日志级别
logging.basicConfig(filename='logger2.log', level=logging.INFO,
                    format="%(asctime)s %(filename)s %(lineno)d %(message)s",
                    datefmt="%a %d %b %Y %H:%M:%S")


# from   import python_dispatch


class Issue(HubotScript):
  test_model = gensim.models.Word2Vec.load_word2vec_format(
    'node_modules/hubot-python-scripts/scripts/recommend/vectors.bin', binary=True)

  @hear(u'^提问：([\s\S]+)#红包：([0-9]+)#$')  # 1.监听对话
  def say(self, message, matches):
    config = {
      'host': 'localhost',
      'port': 3306,
      'user': 'root',
      'password': 'password',
      'db': 'hubot',
      'charset': 'utf8mb4',
      'cursorclass': pymysql.cursors.DictCursor,
    }
    conn = pymysql.connect(**config)
    cursor = conn.cursor()

    try:
      logging.error('#issue1')
      # 2.查找语料库,有的,直接回复,没有的则--

      # 3.在数据库的问题列表中记录数据  用户名--问题内容--问题是否closed

      # 3.1 查找该用户的剩余积分
      search = re.search('^[\s]+$', matches[0], re.IGNORECASE)
      if search:
        logging.error('#issue2')
        message['message'] = "抱歉，问题不能为空哦~"
        content = json.dumps(message)
        return "-1&&" + content
      else:
        bonus = float(matches[1])
        value = [message['user']['name']]
        cursor.execute('select Bonus,NickName,freebonus from contact where UserName = %s', value)
        conn.commit()
        result = cursor.fetchone()
        if result is not None:
          remainingBonus = float(result['Bonus'])
          remainingFreeBonus = float(result['freebonus'])
          totalBonus = remainingBonus + remainingFreeBonus
          nickname = result['NickName']

          # else:
          # 先把问题放进用户的  issuebuffer
          try:
            cursor.execute('update contact set issuebuffer =  %s where UserName = %s',
                           [message['message'], message['user']['name']])
            logging.error('#issue3')

          except Exception as e:
            conn.rollback()  # 事务回滚
            print('sql error', e)
          else:
            conn.commit()  # 事务提交
            # 查找问题库,有没有完全相同的问题
            value = [matches[0]]
            cursor.execute('select  best_solution_id from issue where content = %s', value)
            conn.commit()
            result = cursor.fetchone()
            if result is not None:
              logging.error('#issue41')
              best_solution_id = result['best_solution_id']
              if best_solution_id != 0:
                logging.error('#is sue42')
                cursor.execute('select contentfrom solution where id= %s', [best_solution_id])
                conn.commit()
                result = cursor.fetchone()
                if result is not None:
                  logging.error('#issue43')
                  tmp_answer = result['content']
                  if tmp_answer != "":
                    logging.error('#issue44')
                    message['message'] = u"历史解答：" + tmp_answer + u"\n如果您对这个答案不满意，请回复小智：不满意"
                    content = json.dumps(message)
                    return "-1&&" + content

                  else:
                    msg = self.bonus_not_enough(totalBonus, bonus, message)
                    if msg == 1:
                      logging.error('#issue31')
                      back = self.publish_issue(bonus, conn, cursor, matches, message, nickname, remainingBonus,
                                                remainingFreeBonus)
                      if back == 1 or back == 2:
                        pass
                      else:
                        logging.error('#issue31')
                        return back

                    elif msg == 2:
                      pass
                    else:
                      logging.error('#issue33')
                      return msg

                else:
                  msg = self.bonus_not_enough(totalBonus, bonus, message)
                  if msg == 1:
                    logging.error('#issue5')
                    back = self.publish_issue(bonus, conn, cursor, matches, message, nickname, remainingBonus,
                                              remainingFreeBonus)
                    if back == 1 or back == 2:
                      pass
                    else:
                      logging.error('#issue6')
                      return back

                  elif msg == 2:
                    pass
                  else:
                    logging.error('#issue7')
                    return msg
              else:
                msg = self.bonus_not_enough(totalBonus, bonus, message)
                if msg == 1:
                  logging.error('#issue21')
                  back = self.publish_issue(bonus, conn, cursor, matches, message, nickname, remainingBonus,
                                            remainingFreeBonus)
                  if back == 1 or back == 2:
                    pass
                  else:
                    logging.error('#issue21')
                    return back

                elif msg == 2:
                  pass
                else:
                  logging.error('#issue23')
                  return msg

            else:
              logging.error('#issue45')
              msg = self.bonus_not_enough(totalBonus, bonus, message)
              logging.error('#issue100')
              if msg == 1:
                back = self.publish_issue(bonus, conn, cursor, matches, message, nickname, remainingBonus,
                                          remainingFreeBonus)
                if back == 1 or back == 2:
                  pass
                else:
                  logging.error('#issue8')
                  return back

              elif msg == 2:
                pass
              else:
                logging.error('#issue9')
                return msg
    except:

      traceback.print_exc()
      # 发生错误时会滚
      conn.rollback()

    finally:  # 关闭游标连接
      cursor.close()
      # 关闭数据库连接
      conn.close()

  def bonus_not_enough(self, totalBonus, bonus, message):
    try:
      if totalBonus < bonus:
        logging.error('#bonus_not_enough1')
        # 提示用户
        message['message'] = u"抱歉，您剩余的资产为：" + str(totalBonus) + u"元，小于您发送红包的" \
                                                                            u"数量：" + str(
          bonus) + u"元，多回答问题赚红包吧~"
        logging.error('#bonus_not_enough2')
        content = json.dumps(message)
        return "-1&&" + content
      return 1
    except Exception, e:
      traceback.print_exc()
      logging.error('#bonus_not_enoug3')
      return 2

  # 发布问题
  def publish_issue(self, bonus, conn, cursor, matches, message, nickname, remainingBonus,
                    remainingFreeBonus):
    try:
      # 扣钱
      tmp = bonus - remainingBonus
      if tmp > 0:
        # 说明赠送的那部分不够
        remainingFreeBonus -= tmp
        remainingBonus = 0
      else:
        remainingBonus -= bonus
      logging.error("issue:publish_issue 01")
      # logging.error('remainingBonus:' + remainingBonus + 'remainingFreeBonus:' + remainingFreeBonus)
      # 更新剩余金额数
      value = [remainingBonus, remainingFreeBonus, nickname]
      cursor.execute('update contact set Bonus = %s , freebonus = %s where NickName = %s', value)
      conn.commit()
      logging.error("issue:publish_issue 02")
      # 发布问题
      value = [nickname, matches[0], bonus]
      cursor.execute('INSERT INTO issue (request,content,bonus) VALUES (%s,%s,%s)', value)
      conn.commit()
      new_id = str(cursor.lastrowid)
      # 4.相关度排序筛选出三个人，如果问题语法不合适就默认[u"梁旭磊", u"图灵机器人", u"贤二机器僧"
      logging.error("issue:publish_issue 03")
      #recommend_list = ["梁旭磊", "改变自己", "星"]

      recommend_list = self.recommend_persons(matches[0])
      recommend_names = []  # 存储推荐用户的ID(UserName)
      # 得到推荐用户的UserName
      max_number = 3
      point = 0
      logging.error("issue:publish_issue 04")
      for i in range(recommend_list.__len__()):
        cursor.execute('SELECT UserName FROM contact WHERE NickName = %s', [recommend_list[i]])
        conn.commit()
        if recommend_names.__len__() < max_number:  # 检查推荐人数上限
          username = cursor.fetchone()['UserName']
          if username <> message['user']['name']:
            recommend_names.insert(point, username)
            point += 1
      logging.error("issue:publish_issue 05")
      # 5.广播给推荐列表里的用户
      # if nickname is not None:
      broadcast = u"【红包问题】#" + new_id + u" 提问者：" + nickname + u"\n" + matches[
        0]  + u"\n\n您能告诉小智这个问题的答案吗？\n" \
                  u"正确的回复格式：\n" \
                  u"解答" + new_id + u"：[您的解答]"

      logging.error("issue:publish_issue 06")
        # ""Please think it over and try to solve, if your answer is accepted,you can get " + str(
        # bonus) + " reward bonus\n\n" \
        #          "Right answer form is below:\n" \
        #          "solution for issue #" + new_id + ":[your answer here]"

      # 回复题主
      message['message'] = u"小智已经收到您的红包问题，包含" + str(
        bonus) + u"元，正在帮您请教最有可能知道答案的朋友们~\n"
      content = json.dumps(message)

      data = "0&&" + content
      for j in range(recommend_names.__len__()):
        # 转发给第一个人
        msg1 = {"type": "hear",
                "message": broadcast,
                "user": {"room": "", "name": str(recommend_names[j])}
                }
        content1 = json.dumps(msg1)
        data += "&&" + content1
      return data
      # return 1
    except Exception, e:
      traceback.print_exc()
      return 2

  def del_repeat(self, list):
    for x in list:
      while list.count(x) > 1:
        del list[list.index(x)]
    return list

  def recommend_persons(self,textin):
    logging.error('recommend_persons')
    config = {
      'host': 'localhost',
      'port': 3306,
      'user': 'root',
      'password': 'password',
      'db': 'hubot',
      'charset': 'utf8mb4',
      'cursorclass': pymysql.cursors.DictCursor,
    }
    conn = pymysql.connect(**config)
    cursor = conn.cursor()
    logging.error('#0001')
    cursor.execute('SELECT NickName,Tags FROM contact')
    conn.commit()
    result = cursor.fetchall()
    words = pseg.cut(textin)
    flag = 0
    heap = []  # 用于存储排序结果，不过是逆序的，为了便于去重
    logging.error('#0002')
    for w in words:
      # print w.word,w.flag
      if ((w.flag == u'l') | (w.flag == u'v') | (w.flag == u'n') | (w.flag == u'nr') | (w.flag == u'ns') | (
          w.flag == u'nt') | (w.flag == u'nz') | (
          w.flag == u'Ng') | (w.flag == u'j')):
        flag = 1
        for user in result:
          # print user
          maxsim = 0
          tags = user['Tags'].split(' ')
          for tag in tags:
            # print "word,tag:",w.word,tag
            if tag:
              try:
                similar = self.test_model.similarity(w.word, tag)
              except:
                continue
              if (similar > maxsim):
                maxsim = similar
                # target = user
          heapq.heappush(heap, (maxsim, user))
    logging.error('#0003')
    if flag == 1:
      logging.error('#0004')
      recommend_list = [heapq.heappop(heap)[1]['NickName'] for i in range(len(heap))]
      # list去重
      logging.error('#0005')
      recommend_list = self.del_repeat(recommend_list)
      return recommend_list[::-1]
    else:
      logging.error('#0008')
      # 遇到了不可推荐的问题
      return ["梁旭磊", "改变自己", "星"]

    cursor.close()
    conn.close()
